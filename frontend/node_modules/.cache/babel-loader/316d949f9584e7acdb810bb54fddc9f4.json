{"ast":null,"code":"import { Holistic, POSE_CONNECTIONS, HAND_CONNECTIONS } from \"@mediapipe/holistic/holistic\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport { drawConnectors, drawLandmarks } from \"@mediapipe/drawing_utils/drawing_utils\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\"; // export default function  bodyPose (webcamRef, canvasRef){\n//   const holistic = new Holistic({\n//     locateFile: (file) => {\n//       return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n//     },\n//   });\n//   holistic.setOptions({\n//     modelComplexity: 3,\n//     smoothLandmarks: true,\n//     enableSegmentation: true,\n//     smoothSegmentation: true,\n//     refineFaceLandmarks: true,\n//     minDetectionConfidence: 0.5,\n//     minTrackingConfidence: 0.5,\n//   });\n//   holistic.onResults((results) => {\n//     const videoWidth = webcamRef.current.video.videoWidth;\n//     const videoHeight = webcamRef.current.video.videoHeight;\n//     // Set canvas width\n//     canvasRef.current.width = videoWidth;\n//     canvasRef.current.height = videoHeight;\n//     const canvasElement = canvasRef.current;\n//     const canvasCtx = canvasElement.getContext(\"2d\");\n//     canvasCtx.save();\n//     canvasCtx.globalCompositeOperation = \"source-over\";\n//     drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n//       color: \"#00FF00\",\n//       lineWidth: 4,\n//     });\n//     drawLandmarks(canvasCtx, results.poseLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#CC0000\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n//       color: \"#00FF00\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#00CC00\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     canvasCtx.restore();\n//   });\n//   const camera = new Camera(webcamRef.current.video, {\n//     onFrame: async () => {\n//       await holistic.send({ image: webcamRef.current.video });\n//     },\n//     width: 1280,\n//     height: 720,\n//   });\n//   camera.start();\n// };\n\nexport default function solve(webcamRef, canvasRef) {\n  const faceMesh = new FaceMesh({\n    locateFile: file => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n    }\n  });\n  faceMesh.setOptions({\n    maxNumFaces: 4,\n    refineLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5\n  });\n  faceMesh.onResults(results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight; // Set canvas width\n\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    if (results.multiFaceLandmarks) {\n      for (const landmarks of results.multiFaceLandmarks) {\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n          color: \"#C0C0C070\",\n          lineWidth: 1\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n          color: \"#FF3030\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n          color: \"#FF3030\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n          color: \"#30FF30\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n          color: \"#30FF30\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n          color: \"#E0E0E0\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n          color: \"#E0E0E0\"\n        });\n      }\n    }\n\n    canvasCtx.restore();\n  });\n\n  if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n    const camera = new Camera(webcamRef.current.video, {\n      onFrame: async () => {\n        await faceMesh.send({\n          image: webcamRef.current.video\n        });\n      },\n      width: 1280,\n      height: 720\n    });\n    camera.start();\n  }\n} // export default function BodyPoseDetection() {\n//   const webcamRef = useRef(null);\n//   const canvasRef = useRef(null);\n//   function Results(results) {\n//     // const video = webcamRef.current.video;\n//     const videoWidth = webcamRef.current.video.videoWidth;\n//     const videoHeight = webcamRef.current.video.videoHeight;\n//     // Set canvas width\n//     canvasRef.current.width = videoWidth;\n//     canvasRef.current.height = videoHeight;\n//     const canvasElement = canvasRef.current;\n//     const canvasCtx = canvasElement.getContext(\"2d\");\n//     canvasCtx.save();\n//     // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//     // canvasCtx.drawImage(\n//     //   results.segmentationMask,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n//     // Only overwrite existing pixels.\n//     // canvasCtx.globalCompositeOperation = \"source-in\";\n//     // canvasCtx.fillStyle = \"#00FF00\";\n//     // canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n//     // // Only overwrite missing pixels.\n//     // canvasCtx.globalCompositeOperation = \"destination-atop\";\n//     // canvasCtx.drawImage(\n//     //   results.image,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n//     canvasCtx.globalCompositeOperation = \"source-over\";\n//     drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n//       color: \"#00FF00\",\n//       lineWidth: 4,\n//     });\n//     drawLandmarks(canvasCtx, results.poseLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     // drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {\n//     //   color: \"#C0C0C070\",\n//     //   lineWidth: 1,\n//     // });\n//     drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#CC0000\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n//       color: \"#00FF00\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#00CC00\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     canvasCtx.restore();\n//     console.log(\"done\");\n//   }\n//   // }\n//   // setInterval(())\n//   useEffect(() => {\n//     const holistic = new Holistic({\n//       locateFile: (file) => {\n//         return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n//       },\n//     });\n//     holistic.setOptions({\n//       modelComplexity: 3,\n//       smoothLandmarks: true,\n//       enableSegmentation: true,\n//       smoothSegmentation: true,\n//       refineFaceLandmarks: true,\n//       minDetectionConfidence: 0.5,\n//       minTrackingConfidence: 0.5,\n//     });\n//     holistic.onResults(Results);\n//     const camera = new Camera(webcamRef.current.video, {\n//       onFrame: async () => {\n//         await holistic.send({ image: webcamRef.current.video });\n//       },\n//       width: 1280,\n//       height: 720,\n//     });\n//     camera.start();\n//   }, []);\n//   return (\n//     <center>\n//       <div className=\"App\">\n//         <Webcam\n//           ref={webcamRef}\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         />{\" \"}\n//         <canvas\n//           ref={canvasRef}\n//           className=\"output_canvas\"\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         ></canvas>\n//       </div>\n//     </center>\n//   );\n// }","map":{"version":3,"sources":["/home/deep/Imbesideyou/Imbesideyou_assignment/src/components/features/bodyPoseDetection.js"],"names":["Holistic","POSE_CONNECTIONS","HAND_CONNECTIONS","Camera","drawConnectors","drawLandmarks","Facemesh","FaceMesh","solve","webcamRef","canvasRef","faceMesh","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","videoWidth","current","video","videoHeight","width","height","canvasElement","canvasCtx","getContext","save","clearRect","drawImage","image","multiFaceLandmarks","landmarks","FACEMESH_TESSELATION","color","lineWidth","FACEMESH_RIGHT_EYE","FACEMESH_RIGHT_EYEBROW","FACEMESH_LEFT_EYE","FACEMESH_LEFT_EYEBROW","FACEMESH_FACE_OVAL","FACEMESH_LIPS","restore","camera","onFrame","send","start"],"mappings":"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OAAV;AACC,GA9CD;;AAgDA,MACE,OAAOpC,SAAS,CAACa,OAAjB,KAA6B,WAA7B,IACAb,SAAS,CAACa,OAAV,KAAsB,IAFxB,EAGE;AACA,UAAMwB,MAAM,GAAG,IAAI3C,MAAJ,CAAWM,SAAS,CAACa,OAAV,CAAkBC,KAA7B,EAAoC;AACjDwB,MAAAA,OAAO,EAAE,YAAY;AACnB,cAAMpC,QAAQ,CAACqC,IAAT,CAAc;AAAEf,UAAAA,KAAK,EAAExB,SAAS,CAACa,OAAV,CAAkBC;AAA3B,SAAd,CAAN;AACD,OAHgD;AAIjDE,MAAAA,KAAK,EAAE,IAJ0C;AAKjDC,MAAAA,MAAM,EAAE;AALyC,KAApC,CAAf;AAOAoB,IAAAA,MAAM,CAACG,KAAP;AACD;AACF,C,CAED;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import {\n  Holistic,\n  POSE_CONNECTIONS,\n  HAND_CONNECTIONS,\n} from \"@mediapipe/holistic/holistic\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from \"@mediapipe/drawing_utils/drawing_utils\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\n\n// export default function  bodyPose (webcamRef, canvasRef){\n//   const holistic = new Holistic({\n//     locateFile: (file) => {\n//       return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n//     },\n//   });\n//   holistic.setOptions({\n//     modelComplexity: 3,\n//     smoothLandmarks: true,\n//     enableSegmentation: true,\n//     smoothSegmentation: true,\n//     refineFaceLandmarks: true,\n//     minDetectionConfidence: 0.5,\n//     minTrackingConfidence: 0.5,\n//   });\n//   holistic.onResults((results) => {\n//     const videoWidth = webcamRef.current.video.videoWidth;\n//     const videoHeight = webcamRef.current.video.videoHeight;\n\n//     // Set canvas width\n//     canvasRef.current.width = videoWidth;\n//     canvasRef.current.height = videoHeight;\n\n//     const canvasElement = canvasRef.current;\n//     const canvasCtx = canvasElement.getContext(\"2d\");\n\n//     canvasCtx.save();\n//     canvasCtx.globalCompositeOperation = \"source-over\";\n//     drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n//       color: \"#00FF00\",\n//       lineWidth: 4,\n//     });\n//     drawLandmarks(canvasCtx, results.poseLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#CC0000\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n//       color: \"#00FF00\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#00CC00\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     canvasCtx.restore();\n//   });\n\n//   const camera = new Camera(webcamRef.current.video, {\n//     onFrame: async () => {\n//       await holistic.send({ image: webcamRef.current.video });\n//     },\n//     width: 1280,\n//     height: 720,\n//   });\n//   camera.start();\n// };\n\nexport default function solve(webcamRef ,  canvasRef) {\n  const faceMesh = new FaceMesh({\n    locateFile: (file) => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n    },\n  });\n\n  faceMesh.setOptions({\n    maxNumFaces: 4,\n    refineLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5,\n  });\n\n  faceMesh.onResults((results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n  const videoHeight = webcamRef.current.video.videoHeight;\n\n  // Set canvas width\n  canvasRef.current.width = videoWidth;\n  canvasRef.current.height = videoHeight;\n\n  const canvasElement = canvasRef.current;\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  canvasCtx.save();\n  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  canvasCtx.drawImage(\n    results.image,\n    0,\n    0,\n    canvasElement.width,\n    canvasElement.height\n  );\n  if (results.multiFaceLandmarks) {\n    for (const landmarks of results.multiFaceLandmarks) {\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n        color: \"#C0C0C070\",\n        lineWidth: 1,\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n        color: \"#FF3030\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n        color: \"#FF3030\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n        color: \"#30FF30\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n        color: \"#30FF30\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n        color: \"#E0E0E0\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n        color: \"#E0E0E0\",\n      });\n    }\n  }\n  canvasCtx.restore();\n  });\n\n  if (\n    typeof webcamRef.current !== \"undefined\" &&\n    webcamRef.current !== null\n  ) {\n    const camera = new Camera(webcamRef.current.video, {\n      onFrame: async () => {\n        await faceMesh.send({ image: webcamRef.current.video });\n      },\n      width: 1280,\n      height: 720,\n    });\n    camera.start();\n  }\n}\n\n// export default function BodyPoseDetection() {\n//   const webcamRef = useRef(null);\n//   const canvasRef = useRef(null);\n\n//   function Results(results) {\n//     // const video = webcamRef.current.video;\n//     const videoWidth = webcamRef.current.video.videoWidth;\n//     const videoHeight = webcamRef.current.video.videoHeight;\n\n//     // Set canvas width\n//     canvasRef.current.width = videoWidth;\n//     canvasRef.current.height = videoHeight;\n\n//     const canvasElement = canvasRef.current;\n//     const canvasCtx = canvasElement.getContext(\"2d\");\n\n//     canvasCtx.save();\n//     // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//     // canvasCtx.drawImage(\n//     //   results.segmentationMask,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n\n//     // Only overwrite existing pixels.\n//     // canvasCtx.globalCompositeOperation = \"source-in\";\n//     // canvasCtx.fillStyle = \"#00FF00\";\n//     // canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n\n//     // // Only overwrite missing pixels.\n//     // canvasCtx.globalCompositeOperation = \"destination-atop\";\n//     // canvasCtx.drawImage(\n//     //   results.image,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n\n//     canvasCtx.globalCompositeOperation = \"source-over\";\n//     drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n//       color: \"#00FF00\",\n//       lineWidth: 4,\n//     });\n//     drawLandmarks(canvasCtx, results.poseLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     // drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {\n//     //   color: \"#C0C0C070\",\n//     //   lineWidth: 1,\n//     // });\n//     drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#CC0000\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n//       color: \"#00FF00\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#00CC00\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     canvasCtx.restore();\n//     console.log(\"done\");\n//   }\n//   // }\n\n//   // setInterval(())\n//   useEffect(() => {\n//     const holistic = new Holistic({\n//       locateFile: (file) => {\n//         return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n//       },\n//     });\n//     holistic.setOptions({\n//       modelComplexity: 3,\n//       smoothLandmarks: true,\n//       enableSegmentation: true,\n//       smoothSegmentation: true,\n//       refineFaceLandmarks: true,\n//       minDetectionConfidence: 0.5,\n//       minTrackingConfidence: 0.5,\n//     });\n//     holistic.onResults(Results);\n\n//     const camera = new Camera(webcamRef.current.video, {\n//       onFrame: async () => {\n//         await holistic.send({ image: webcamRef.current.video });\n//       },\n//       width: 1280,\n//       height: 720,\n//     });\n//     camera.start();\n//   }, []);\n\n//   return (\n//     <center>\n//       <div className=\"App\">\n//         <Webcam\n//           ref={webcamRef}\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         />{\" \"}\n//         <canvas\n//           ref={canvasRef}\n//           className=\"output_canvas\"\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         ></canvas>\n//       </div>\n//     </center>\n//   );\n// }\n"]},"metadata":{},"sourceType":"module"}