{"ast":null,"code":"// import React, { useRef, useEffect } from \"react\";\nimport { Holistic, POSE_CONNECTIONS, HAND_CONNECTIONS, FACEMESH_TESSELATION } from \"@mediapipe/holistic/holistic\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport Webcam from \"react-webcam\";\nimport { drawConnectors, drawLandmarks } from \"@mediapipe/drawing_utils/drawing_utils\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\nexport default function BodyPose(webcamRef, canvasRef) {\n  const holistic = new Holistic({\n    locateFile: file => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n    }\n  });\n  holistic.setOptions({\n    modelComplexity: 1,\n    smoothLandmarks: true,\n    enableSegmentation: true,\n    smoothSegmentation: true,\n    refineFaceLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5\n  });\n  holistic.onResults(results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight; // Set canvas width\n\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save(); // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n    // canvasCtx.drawImage(results.segmentationMask, 0, 0,\n    //                     canvasElement.width, canvasElement.height);\n    // // Only overwrite existing pixels.\n    // canvasCtx.globalCompositeOperation = 'source-in';\n    // canvasCtx.fillStyle = '#00FF00';\n    // canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n    // // Only overwrite missing pixels.\n    // canvasCtx.globalCompositeOperation = 'destination-atop';\n    // canvasCtx.drawImage(\n    //     results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    canvasCtx.globalCompositeOperation = 'source-over';\n    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n      color: '#FFF',\n      lineWidth: 4\n    });\n    drawLandmarks(canvasCtx, results.poseLandmarks, {\n      color: '#000',\n      lineWidth: 2\n    });\n    drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {\n      color: '#C0C0C070',\n      lineWidth: 1\n    });\n    drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n      color: '#FFF',\n      lineWidth: 5\n    });\n    drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n      color: '#0009',\n      lineWidth: 2\n    });\n    drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n      color: '#FFF',\n      lineWidth: 5\n    });\n    drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n      color: '#0009',\n      lineWidth: 2\n    });\n    canvasCtx.restore();\n  });\n  const camera = new Camera(webcamRef.current.video, {\n    onFrame: async () => {\n      await holistic.send({\n        image: webcamRef.current.video\n      });\n    },\n    width: 1280,\n    height: 720\n  });\n  camera.start();\n}\n_c = BodyPose;\n;\n\nvar _c;\n\n$RefreshReg$(_c, \"BodyPose\");","map":{"version":3,"sources":["/home/deep/Imbesideyou/Imbesideyou_assignment/frontend/src/components/features/bodyPoseDetection.js"],"names":["Holistic","POSE_CONNECTIONS","HAND_CONNECTIONS","FACEMESH_TESSELATION","Camera","Webcam","drawConnectors","drawLandmarks","Facemesh","FaceMesh","BodyPose","webcamRef","canvasRef","holistic","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","refineFaceLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","videoWidth","current","video","videoHeight","width","height","canvasElement","canvasCtx","getContext","save","globalCompositeOperation","poseLandmarks","color","lineWidth","faceLandmarks","leftHandLandmarks","rightHandLandmarks","restore","camera","onFrame","send","image","start"],"mappings":"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","sourcesContent":["// import React, { useRef, useEffect } from \"react\";\nimport {\n  Holistic,\n  POSE_CONNECTIONS,\n  HAND_CONNECTIONS,\n  FACEMESH_TESSELATION\n} from \"@mediapipe/holistic/holistic\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport Webcam from \"react-webcam\";\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from \"@mediapipe/drawing_utils/drawing_utils\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\n\nexport default function  BodyPose(webcamRef, canvasRef){\n  const holistic = new Holistic({locateFile: (file) => {\n    return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n  }});\n  holistic.setOptions({\n    modelComplexity: 1,\n    smoothLandmarks: true,\n    enableSegmentation: true,\n    smoothSegmentation: true,\n    refineFaceLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5\n  });\n  holistic.onResults((results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas width\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n\n\n    canvasCtx.save();\n  // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  // canvasCtx.drawImage(results.segmentationMask, 0, 0,\n  //                     canvasElement.width, canvasElement.height);\n\n  // // Only overwrite existing pixels.\n  // canvasCtx.globalCompositeOperation = 'source-in';\n  // canvasCtx.fillStyle = '#00FF00';\n  // canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n\n  // // Only overwrite missing pixels.\n  // canvasCtx.globalCompositeOperation = 'destination-atop';\n  // canvasCtx.drawImage(\n  //     results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n  canvasCtx.globalCompositeOperation = 'source-over';\n  drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,\n                 {color: '#FFF', lineWidth: 4});\n  drawLandmarks(canvasCtx, results.poseLandmarks,\n                {color: '#000', lineWidth: 2});\n  drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION,\n                 {color: '#C0C0C070', lineWidth: 1});\n  drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS,\n                 {color: '#FFF', lineWidth: 5});\n  drawLandmarks(canvasCtx, results.leftHandLandmarks,\n                {color: '#0009', lineWidth: 2});\n  drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS,\n                 {color: '#FFF', lineWidth: 5});\n  drawLandmarks(canvasCtx, results.rightHandLandmarks,\n                {color: '#0009', lineWidth: 2});\n  canvasCtx.restore();\n  });\n  \n  const camera = new Camera( webcamRef.current.video, {\n    onFrame: async () => {\n      await holistic.send({image:  webcamRef.current.video});\n    },\n    width: 1280,\n    height: 720\n  });\n  camera.start();\n  \n\n};\n\n\n\n"]},"metadata":{},"sourceType":"module"}