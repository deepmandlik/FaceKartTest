{"ast":null,"code":"import { FaceMesh } from \"@mediapipe/face_mesh\";\nimport React, { useRef, useEffect } from \"react\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport { drawConnectors } from '@mediapipe/drawing_utils/drawing_utils';\nimport Webcam from \"react-webcam\";\nexport default function solve(webcamRef, canvasRef) {\n  const faceMesh = new FaceMesh({\n    locateFile: file => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n    }\n  });\n  faceMesh.setOptions({\n    maxNumFaces: 4,\n    refineLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5\n  });\n  faceMesh.onResults(results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight; // Set canvas width\n\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    if (results.multiFaceLandmarks) {\n      for (const landmarks of results.multiFaceLandmarks) {\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n          color: \"#C0C0C070\",\n          lineWidth: 1\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n          color: \"#FF3030\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n          color: \"#FF3030\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n          color: \"#30FF30\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n          color: \"#30FF30\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n          color: \"#E0E0E0\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n          color: \"#E0E0E0\"\n        });\n      }\n    }\n\n    canvasCtx.restore();\n  });\n\n  if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n    const camera = new Camera(webcamRef.current.video, {\n      onFrame: async () => {\n        await faceMesh.send({\n          image: webcamRef.current.video\n        });\n      },\n      width: 1280,\n      height: 720\n    });\n    camera.start();\n  }\n} // export default function FaceLandmarkDetection() {\n//   const webcamRef = useRef(null);\n//   const canvasRef = useRef(null);\n//   // function onResults(results) {\n//   //   // const video = webcamRef.current.video;\n//   //   const videoWidth = webcamRef.current.video.videoWidth;\n//   //   const videoHeight = webcamRef.current.video.videoHeight;\n//   //   // Set canvas width\n//   //   canvasRef.current.width = videoWidth;\n//   //   canvasRef.current.height = videoHeight;\n//   //   const canvasElement = canvasRef.current;\n//   //   const canvasCtx = canvasElement.getContext(\"2d\");\n//   //   canvasCtx.save();\n//   //   canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//   //   canvasCtx.drawImage(\n//   //     results.image,\n//   //     0,\n//   //     0,\n//   //     canvasElement.width,\n//   //     canvasElement.height\n//   //   );\n//   //   if (results.multiFaceLandmarks) {\n//   //     for (const landmarks of results.multiFaceLandmarks) {\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n//   //         color: \"#C0C0C070\",\n//   //         lineWidth: 1,\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n//   //         color: \"#FF3030\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n//   //         color: \"#FF3030\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n//   //         color: \"#30FF30\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n//   //         color: \"#30FF30\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n//   //         color: \"#E0E0E0\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n//   //         color: \"#E0E0E0\",\n//   //       });\n//   //     }\n//   //   }\n//   //   canvasCtx.restore();\n//   // }\n//   // }\n//   // setInterval(())\n//   useEffect(() => {\n//     // const faceMesh = new FaceMesh({\n//     //   locateFile: (file) => {\n//     //     return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n//     //   },\n//     // });\n//     // faceMesh.setOptions({\n//     //   maxNumFaces: 4,\n//     //   refineLandmarks: true,\n//     //   minDetectionConfidence: 0.5,\n//     //   minTrackingConfidence: 0.5,\n//     // });\n//     // faceMesh.onResults((results) => {\n//     //   const videoWidth = webcamRef.current.video.videoWidth;\n//     // const videoHeight = webcamRef.current.video.videoHeight;\n//     // // Set canvas width\n//     // canvasRef.current.width = videoWidth;\n//     // canvasRef.current.height = videoHeight;\n//     // const canvasElement = canvasRef.current;\n//     // const canvasCtx = canvasElement.getContext(\"2d\");\n//     // canvasCtx.save();\n//     // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//     // canvasCtx.drawImage(\n//     //   results.image,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n//     // if (results.multiFaceLandmarks) {\n//     //   for (const landmarks of results.multiFaceLandmarks) {\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n//     //       color: \"#C0C0C070\",\n//     //       lineWidth: 1,\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n//     //       color: \"#FF3030\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n//     //       color: \"#FF3030\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n//     //       color: \"#30FF30\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n//     //       color: \"#30FF30\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n//     //       color: \"#E0E0E0\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n//     //       color: \"#E0E0E0\",\n//     //     });\n//     //   }\n//     // }\n//     // canvasCtx.restore();\n//     // });\n//     // if (\n//     //   typeof webcamRef.current !== \"undefined\" &&\n//     //   webcamRef.current !== null\n//     // ) {\n//     //   const camera = new Camera(webcamRef.current.video, {\n//     //     onFrame: async () => {\n//     //       await faceMesh.send({ image: webcamRef.current.video });\n//     //     },\n//     //     width: 1280,\n//     //     height: 720,\n//     //   });\n//     //   camera.start();\n//     // }\n//     solve(webcamRef ,canvasRef);\n//   }, []);\n//   return (\n//     <center>\n//       <div className=\"App\">\n//         <Webcam\n//           ref={webcamRef}\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         />{\" \"}\n//         <canvas\n//           ref={canvasRef}\n//           className=\"output_canvas\"\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         ></canvas>\n//       </div>\n//     </center>\n//   );\n// }","map":{"version":3,"sources":["/home/deep/Imbesideyou/Imbesideyou_assignment/src/components/features/faceLandmarkDetection.js"],"names":["FaceMesh","React","useRef","useEffect","Facemesh","Camera","drawConnectors","Webcam","solve","webcamRef","canvasRef","faceMesh","locateFile","file","setOptions","maxNumFaces","refineLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","videoWidth","current","video","videoHeight","width","height","canvasElement","canvasCtx","getContext","save","clearRect","drawImage","image","multiFaceLandmarks","landmarks","FACEMESH_TESSELATION","color","lineWidth","FACEMESH_RIGHT_EYE","FACEMESH_RIGHT_EYEBROW","FACEMESH_LEFT_EYE","FACEMESH_LEFT_EYEBROW","FACEMESH_FACE_OVAL","FACEMESH_LIPS","restore","camera","onFrame","send","start"],"mappings":"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,CAAkBC;AAA3B,SAAd,CAAN;AACD,OAHgD;AAIjDE,MAAAA,KAAK,EAAE,IAJ0C;AAKjDC,MAAAA,MAAM,EAAE;AALyC,KAApC,CAAf;AAOAoB,IAAAA,MAAM,CAACG,KAAP;AACD;AACF,C,CAGD;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { FaceMesh } from \"@mediapipe/face_mesh\";\nimport React, { useRef, useEffect } from \"react\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport {drawConnectors}  from '@mediapipe/drawing_utils/drawing_utils';\nimport Webcam from \"react-webcam\";\n\n\nexport default function solve(webcamRef ,  canvasRef) {\n  const faceMesh = new FaceMesh({\n    locateFile: (file) => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n    },\n  });\n\n  faceMesh.setOptions({\n    maxNumFaces: 4,\n    refineLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5,\n  });\n\n  faceMesh.onResults((results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n  const videoHeight = webcamRef.current.video.videoHeight;\n\n  // Set canvas width\n  canvasRef.current.width = videoWidth;\n  canvasRef.current.height = videoHeight;\n\n  const canvasElement = canvasRef.current;\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  canvasCtx.save();\n  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  canvasCtx.drawImage(\n    results.image,\n    0,\n    0,\n    canvasElement.width,\n    canvasElement.height\n  );\n  if (results.multiFaceLandmarks) {\n    for (const landmarks of results.multiFaceLandmarks) {\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n        color: \"#C0C0C070\",\n        lineWidth: 1,\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n        color: \"#FF3030\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n        color: \"#FF3030\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n        color: \"#30FF30\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n        color: \"#30FF30\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n        color: \"#E0E0E0\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n        color: \"#E0E0E0\",\n      });\n    }\n  }\n  canvasCtx.restore();\n  });\n\n  if (\n    typeof webcamRef.current !== \"undefined\" &&\n    webcamRef.current !== null\n  ) {\n    const camera = new Camera(webcamRef.current.video, {\n      onFrame: async () => {\n        await faceMesh.send({ image: webcamRef.current.video });\n      },\n      width: 1280,\n      height: 720,\n    });\n    camera.start();\n  }\n}\n\n\n// export default function FaceLandmarkDetection() {\n//   const webcamRef = useRef(null);\n//   const canvasRef = useRef(null);\n\n//   // function onResults(results) {\n//   //   // const video = webcamRef.current.video;\n//   //   const videoWidth = webcamRef.current.video.videoWidth;\n//   //   const videoHeight = webcamRef.current.video.videoHeight;\n\n//   //   // Set canvas width\n//   //   canvasRef.current.width = videoWidth;\n//   //   canvasRef.current.height = videoHeight;\n\n//   //   const canvasElement = canvasRef.current;\n//   //   const canvasCtx = canvasElement.getContext(\"2d\");\n//   //   canvasCtx.save();\n//   //   canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//   //   canvasCtx.drawImage(\n//   //     results.image,\n//   //     0,\n//   //     0,\n//   //     canvasElement.width,\n//   //     canvasElement.height\n//   //   );\n//   //   if (results.multiFaceLandmarks) {\n//   //     for (const landmarks of results.multiFaceLandmarks) {\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n//   //         color: \"#C0C0C070\",\n//   //         lineWidth: 1,\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n//   //         color: \"#FF3030\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n//   //         color: \"#FF3030\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n//   //         color: \"#30FF30\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n//   //         color: \"#30FF30\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n//   //         color: \"#E0E0E0\",\n//   //       });\n//   //       drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n//   //         color: \"#E0E0E0\",\n//   //       });\n//   //     }\n//   //   }\n//   //   canvasCtx.restore();\n//   // }\n//   // }\n\n//   // setInterval(())\n//   useEffect(() => {\n//     // const faceMesh = new FaceMesh({\n//     //   locateFile: (file) => {\n//     //     return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n//     //   },\n//     // });\n\n//     // faceMesh.setOptions({\n//     //   maxNumFaces: 4,\n//     //   refineLandmarks: true,\n//     //   minDetectionConfidence: 0.5,\n//     //   minTrackingConfidence: 0.5,\n//     // });\n\n//     // faceMesh.onResults((results) => {\n//     //   const videoWidth = webcamRef.current.video.videoWidth;\n//     // const videoHeight = webcamRef.current.video.videoHeight;\n\n//     // // Set canvas width\n//     // canvasRef.current.width = videoWidth;\n//     // canvasRef.current.height = videoHeight;\n\n//     // const canvasElement = canvasRef.current;\n//     // const canvasCtx = canvasElement.getContext(\"2d\");\n//     // canvasCtx.save();\n//     // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//     // canvasCtx.drawImage(\n//     //   results.image,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n//     // if (results.multiFaceLandmarks) {\n//     //   for (const landmarks of results.multiFaceLandmarks) {\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n//     //       color: \"#C0C0C070\",\n//     //       lineWidth: 1,\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n//     //       color: \"#FF3030\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n//     //       color: \"#FF3030\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n//     //       color: \"#30FF30\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n//     //       color: \"#30FF30\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n//     //       color: \"#E0E0E0\",\n//     //     });\n//     //     drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n//     //       color: \"#E0E0E0\",\n//     //     });\n//     //   }\n//     // }\n//     // canvasCtx.restore();\n//     // });\n\n//     // if (\n//     //   typeof webcamRef.current !== \"undefined\" &&\n//     //   webcamRef.current !== null\n//     // ) {\n//     //   const camera = new Camera(webcamRef.current.video, {\n//     //     onFrame: async () => {\n//     //       await faceMesh.send({ image: webcamRef.current.video });\n//     //     },\n//     //     width: 1280,\n//     //     height: 720,\n//     //   });\n//     //   camera.start();\n//     // }\n//     solve(webcamRef ,canvasRef);\n//   }, []);\n//   return (\n//     <center>\n//       <div className=\"App\">\n//         <Webcam\n//           ref={webcamRef}\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         />{\" \"}\n//         <canvas\n//           ref={canvasRef}\n//           className=\"output_canvas\"\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         ></canvas>\n//       </div>\n//     </center>\n//   );\n// }\n\n"]},"metadata":{},"sourceType":"module"}