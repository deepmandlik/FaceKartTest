{"ast":null,"code":"import { Holistic, POSE_CONNECTIONS, HAND_CONNECTIONS } from \"@mediapipe/holistic/holistic\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport { drawConnectors, drawLandmarks } from \"@mediapipe/drawing_utils/drawing_utils\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\nexport const bodyPose = (webcamRef, canvasRef) => {\n  const holistic = new Holistic({\n    locateFile: file => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n    }\n  });\n  holistic.setOptions({\n    modelComplexity: 3,\n    smoothLandmarks: true,\n    enableSegmentation: true,\n    smoothSegmentation: true,\n    refineFaceLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5\n  });\n  holistic.onResults(results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight; // Set canvas width\n\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.globalCompositeOperation = \"source-over\";\n    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n      color: \"#00FF00\",\n      lineWidth: 4\n    });\n    drawLandmarks(canvasCtx, results.poseLandmarks, {\n      color: \"#FF0000\",\n      lineWidth: 2\n    });\n    drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n      color: \"#CC0000\",\n      lineWidth: 5\n    });\n    drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n      color: \"#00FF00\",\n      lineWidth: 2\n    });\n    drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n      color: \"#00CC00\",\n      lineWidth: 5\n    });\n    drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n      color: \"#FF0000\",\n      lineWidth: 2\n    });\n    canvasCtx.restore();\n  });\n  const camera = new Camera(webcamRef.current.video, {\n    onFrame: async () => {\n      await holistic.send({\n        image: webcamRef.current.video\n      });\n    },\n    width: 1280,\n    height: 720\n  });\n  camera.start();\n};\nexport default function solve(webcamRef, canvasRef) {\n  const faceMesh = new FaceMesh({\n    locateFile: file => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n    }\n  });\n  faceMesh.setOptions({\n    maxNumFaces: 4,\n    refineLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5\n  });\n  faceMesh.onResults(results => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight; // Set canvas width\n\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n    canvasCtx.save();\n    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n    canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);\n\n    if (results.multiFaceLandmarks) {\n      for (const landmarks of results.multiFaceLandmarks) {\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n          color: \"#C0C0C070\",\n          lineWidth: 1\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n          color: \"#FF3030\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n          color: \"#FF3030\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n          color: \"#30FF30\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n          color: \"#30FF30\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n          color: \"#E0E0E0\"\n        });\n        drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n          color: \"#E0E0E0\"\n        });\n      }\n    }\n\n    canvasCtx.restore();\n  });\n\n  if (typeof webcamRef.current !== \"undefined\" && webcamRef.current !== null) {\n    const camera = new Camera(webcamRef.current.video, {\n      onFrame: async () => {\n        await faceMesh.send({\n          image: webcamRef.current.video\n        });\n      },\n      width: 1280,\n      height: 720\n    });\n    camera.start();\n  }\n} // export default function BodyPoseDetection() {\n//   const webcamRef = useRef(null);\n//   const canvasRef = useRef(null);\n//   function Results(results) {\n//     // const video = webcamRef.current.video;\n//     const videoWidth = webcamRef.current.video.videoWidth;\n//     const videoHeight = webcamRef.current.video.videoHeight;\n//     // Set canvas width\n//     canvasRef.current.width = videoWidth;\n//     canvasRef.current.height = videoHeight;\n//     const canvasElement = canvasRef.current;\n//     const canvasCtx = canvasElement.getContext(\"2d\");\n//     canvasCtx.save();\n//     // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//     // canvasCtx.drawImage(\n//     //   results.segmentationMask,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n//     // Only overwrite existing pixels.\n//     // canvasCtx.globalCompositeOperation = \"source-in\";\n//     // canvasCtx.fillStyle = \"#00FF00\";\n//     // canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n//     // // Only overwrite missing pixels.\n//     // canvasCtx.globalCompositeOperation = \"destination-atop\";\n//     // canvasCtx.drawImage(\n//     //   results.image,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n//     canvasCtx.globalCompositeOperation = \"source-over\";\n//     drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n//       color: \"#00FF00\",\n//       lineWidth: 4,\n//     });\n//     drawLandmarks(canvasCtx, results.poseLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     // drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {\n//     //   color: \"#C0C0C070\",\n//     //   lineWidth: 1,\n//     // });\n//     drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#CC0000\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n//       color: \"#00FF00\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#00CC00\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     canvasCtx.restore();\n//     console.log(\"done\");\n//   }\n//   // }\n//   // setInterval(())\n//   useEffect(() => {\n//     const holistic = new Holistic({\n//       locateFile: (file) => {\n//         return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n//       },\n//     });\n//     holistic.setOptions({\n//       modelComplexity: 3,\n//       smoothLandmarks: true,\n//       enableSegmentation: true,\n//       smoothSegmentation: true,\n//       refineFaceLandmarks: true,\n//       minDetectionConfidence: 0.5,\n//       minTrackingConfidence: 0.5,\n//     });\n//     holistic.onResults(Results);\n//     const camera = new Camera(webcamRef.current.video, {\n//       onFrame: async () => {\n//         await holistic.send({ image: webcamRef.current.video });\n//       },\n//       width: 1280,\n//       height: 720,\n//     });\n//     camera.start();\n//   }, []);\n//   return (\n//     <center>\n//       <div className=\"App\">\n//         <Webcam\n//           ref={webcamRef}\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         />{\" \"}\n//         <canvas\n//           ref={canvasRef}\n//           className=\"output_canvas\"\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         ></canvas>\n//       </div>\n//     </center>\n//   );\n// }","map":{"version":3,"sources":["/home/deep/Imbesideyou/Imbesideyou_assignment/src/components/features/bodyPoseDetection.js"],"names":["Holistic","POSE_CONNECTIONS","HAND_CONNECTIONS","Camera","drawConnectors","drawLandmarks","Facemesh","FaceMesh","bodyPose","webcamRef","canvasRef","holistic","locateFile","file","setOptions","modelComplexity","smoothLandmarks","enableSegmentation","smoothSegmentation","refineFaceLandmarks","minDetectionConfidence","minTrackingConfidence","onResults","results","videoWidth","current","video","videoHeight","width","height","canvasElement","canvasCtx","getContext","save","globalCompositeOperation","poseLandmarks","color","lineWidth","leftHandLandmarks","rightHandLandmarks","restore","camera","onFrame","send","image","start","solve","faceMesh","maxNumFaces","refineLandmarks","clearRect","drawImage","multiFaceLandmarks","landmarks","FACEMESH_TESSELATION","FACEMESH_RIGHT_EYE","FACEMESH_RIGHT_EYEBROW","FACEMESH_LEFT_EYE","FACEMESH_LEFT_EYEBROW","FACEMESH_FACE_OVAL","FACEMESH_LIPS"],"mappings":"AAAA,SACEA,QADF,EAEEC,gBAFF,EAGEC,gBAHF,QAIO,8BAJP;AAKA,SAASC,MAAT,QAAuB,sCAAvB;AACA,SACEC,cADF,EAEEC,aAFF,QAGO,wCAHP;AAIA,OAAO,KAAKC,QAAZ,MAA0B,sBAA1B;AACA,SAASC,QAAT,QAAyB,sBAAzB;AACA,OAAO,MAAMC,QAAQ,GAAG,CAACC,SAAD,EAAYC,SAAZ,KAA0B;AAChD,QAAMC,QAAQ,GAAG,IAAIX,QAAJ,CAAa;AAC5BY,IAAAA,UAAU,EAAGC,IAAD,IAAU;AACpB,aAAQ,oDAAmDA,IAAK,EAAhE;AACD;AAH2B,GAAb,CAAjB;AAKAF,EAAAA,QAAQ,CAACG,UAAT,CAAoB;AAClBC,IAAAA,eAAe,EAAE,CADC;AAElBC,IAAAA,eAAe,EAAE,IAFC;AAGlBC,IAAAA,kBAAkB,EAAE,IAHF;AAIlBC,IAAAA,kBAAkB,EAAE,IAJF;AAKlBC,IAAAA,mBAAmB,EAAE,IALH;AAMlBC,IAAAA,sBAAsB,EAAE,GANN;AAOlBC,IAAAA,qBAAqB,EAAE;AAPL,GAApB;AASAV,EAAAA,QAAQ,CAACW,SAAT,CAAoBC,OAAD,IAAa;AAC9B,UAAMC,UAAU,GAAGf,SAAS,CAACgB,OAAV,CAAkBC,KAAlB,CAAwBF,UAA3C;AACA,UAAMG,WAAW,GAAGlB,SAAS,CAACgB,OAAV,CAAkBC,KAAlB,CAAwBC,WAA5C,CAF8B,CAI9B;;AACAjB,IAAAA,SAAS,CAACe,OAAV,CAAkBG,KAAlB,GAA0BJ,UAA1B;AACAd,IAAAA,SAAS,CAACe,OAAV,CAAkBI,MAAlB,GAA2BF,WAA3B;AAEA,UAAMG,aAAa,GAAGpB,SAAS,CAACe,OAAhC;AACA,UAAMM,SAAS,GAAGD,aAAa,CAACE,UAAd,CAAyB,IAAzB,CAAlB;AAEAD,IAAAA,SAAS,CAACE,IAAV;AACAF,IAAAA,SAAS,CAACG,wBAAV,GAAqC,aAArC;AACA9B,IAAAA,cAAc,CAAC2B,SAAD,EAAYR,OAAO,CAACY,aAApB,EAAmClC,gBAAnC,EAAqD;AACjEmC,MAAAA,KAAK,EAAE,SAD0D;AAEjEC,MAAAA,SAAS,EAAE;AAFsD,KAArD,CAAd;AAIAhC,IAAAA,aAAa,CAAC0B,SAAD,EAAYR,OAAO,CAACY,aAApB,EAAmC;AAC9CC,MAAAA,KAAK,EAAE,SADuC;AAE9CC,MAAAA,SAAS,EAAE;AAFmC,KAAnC,CAAb;AAIAjC,IAAAA,cAAc,CAAC2B,SAAD,EAAYR,OAAO,CAACe,iBAApB,EAAuCpC,gBAAvC,EAAyD;AACrEkC,MAAAA,KAAK,EAAE,SAD8D;AAErEC,MAAAA,SAAS,EAAE;AAF0D,KAAzD,CAAd;AAIAhC,IAAAA,aAAa,CAAC0B,SAAD,EAAYR,OAAO,CAACe,iBAApB,EAAuC;AAClDF,MAAAA,KAAK,EAAE,SAD2C;AAElDC,MAAAA,SAAS,EAAE;AAFuC,KAAvC,CAAb;AAIAjC,IAAAA,cAAc,CAAC2B,SAAD,EAAYR,OAAO,CAACgB,kBAApB,EAAwCrC,gBAAxC,EAA0D;AACtEkC,MAAAA,KAAK,EAAE,SAD+D;AAEtEC,MAAAA,SAAS,EAAE;AAF2D,KAA1D,CAAd;AAIAhC,IAAAA,aAAa,CAAC0B,SAAD,EAAYR,OAAO,CAACgB,kBAApB,EAAwC;AACnDH,MAAAA,KAAK,EAAE,SAD4C;AAEnDC,MAAAA,SAAS,EAAE;AAFwC,KAAxC,CAAb;AAIAN,IAAAA,SAAS,CAACS,OAAV;AACD,GAtCD;AAwCA,QAAMC,MAAM,GAAG,IAAItC,MAAJ,CAAWM,SAAS,CAACgB,OAAV,CAAkBC,KAA7B,EAAoC;AACjDgB,IAAAA,OAAO,EAAE,YAAY;AACnB,YAAM/B,QAAQ,CAACgC,IAAT,CAAc;AAAEC,QAAAA,KAAK,EAAEnC,SAAS,CAACgB,OAAV,CAAkBC;AAA3B,OAAd,CAAN;AACD,KAHgD;AAIjDE,IAAAA,KAAK,EAAE,IAJ0C;AAKjDC,IAAAA,MAAM,EAAE;AALyC,GAApC,CAAf;AAOAY,EAAAA,MAAM,CAACI,KAAP;AACD,CA/DM;AAiEP,eAAe,SAASC,KAAT,CAAerC,SAAf,EAA4BC,SAA5B,EAAuC;AACpD,QAAMqC,QAAQ,GAAG,IAAIxC,QAAJ,CAAa;AAC5BK,IAAAA,UAAU,EAAGC,IAAD,IAAU;AACpB,aAAQ,qDAAoDA,IAAK,EAAjE;AACD;AAH2B,GAAb,CAAjB;AAMAkC,EAAAA,QAAQ,CAACjC,UAAT,CAAoB;AAClBkC,IAAAA,WAAW,EAAE,CADK;AAElBC,IAAAA,eAAe,EAAE,IAFC;AAGlB7B,IAAAA,sBAAsB,EAAE,GAHN;AAIlBC,IAAAA,qBAAqB,EAAE;AAJL,GAApB;AAOA0B,EAAAA,QAAQ,CAACzB,SAAT,CAAoBC,OAAD,IAAa;AAC9B,UAAMC,UAAU,GAAGf,SAAS,CAACgB,OAAV,CAAkBC,KAAlB,CAAwBF,UAA3C;AACF,UAAMG,WAAW,GAAGlB,SAAS,CAACgB,OAAV,CAAkBC,KAAlB,CAAwBC,WAA5C,CAFgC,CAIhC;;AACAjB,IAAAA,SAAS,CAACe,OAAV,CAAkBG,KAAlB,GAA0BJ,UAA1B;AACAd,IAAAA,SAAS,CAACe,OAAV,CAAkBI,MAAlB,GAA2BF,WAA3B;AAEA,UAAMG,aAAa,GAAGpB,SAAS,CAACe,OAAhC;AACA,UAAMM,SAAS,GAAGD,aAAa,CAACE,UAAd,CAAyB,IAAzB,CAAlB;AACAD,IAAAA,SAAS,CAACE,IAAV;AACAF,IAAAA,SAAS,CAACmB,SAAV,CAAoB,CAApB,EAAuB,CAAvB,EAA0BpB,aAAa,CAACF,KAAxC,EAA+CE,aAAa,CAACD,MAA7D;AACAE,IAAAA,SAAS,CAACoB,SAAV,CACE5B,OAAO,CAACqB,KADV,EAEE,CAFF,EAGE,CAHF,EAIEd,aAAa,CAACF,KAJhB,EAKEE,aAAa,CAACD,MALhB;;AAOA,QAAIN,OAAO,CAAC6B,kBAAZ,EAAgC;AAC9B,WAAK,MAAMC,SAAX,IAAwB9B,OAAO,CAAC6B,kBAAhC,EAAoD;AAClDhD,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACgD,oBAAhC,EAAsD;AAClElB,UAAAA,KAAK,EAAE,WAD2D;AAElEC,UAAAA,SAAS,EAAE;AAFuD,SAAtD,CAAd;AAIAjC,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACiD,kBAAhC,EAAoD;AAChEnB,UAAAA,KAAK,EAAE;AADyD,SAApD,CAAd;AAGAhC,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACkD,sBAAhC,EAAwD;AACpEpB,UAAAA,KAAK,EAAE;AAD6D,SAAxD,CAAd;AAGAhC,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACmD,iBAAhC,EAAmD;AAC/DrB,UAAAA,KAAK,EAAE;AADwD,SAAnD,CAAd;AAGAhC,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACoD,qBAAhC,EAAuD;AACnEtB,UAAAA,KAAK,EAAE;AAD4D,SAAvD,CAAd;AAGAhC,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACqD,kBAAhC,EAAoD;AAChEvB,UAAAA,KAAK,EAAE;AADyD,SAApD,CAAd;AAGAhC,QAAAA,cAAc,CAAC2B,SAAD,EAAYsB,SAAZ,EAAuB/C,QAAQ,CAACsD,aAAhC,EAA+C;AAC3DxB,UAAAA,KAAK,EAAE;AADoD,SAA/C,CAAd;AAGD;AACF;;AACDL,IAAAA,SAAS,CAACS,OAAV;AACC,GA9CD;;AAgDA,MACE,OAAO/B,SAAS,CAACgB,OAAjB,KAA6B,WAA7B,IACAhB,SAAS,CAACgB,OAAV,KAAsB,IAFxB,EAGE;AACA,UAAMgB,MAAM,GAAG,IAAItC,MAAJ,CAAWM,SAAS,CAACgB,OAAV,CAAkBC,KAA7B,EAAoC;AACjDgB,MAAAA,OAAO,EAAE,YAAY;AACnB,cAAMK,QAAQ,CAACJ,IAAT,CAAc;AAAEC,UAAAA,KAAK,EAAEnC,SAAS,CAACgB,OAAV,CAAkBC;AAA3B,SAAd,CAAN;AACD,OAHgD;AAIjDE,MAAAA,KAAK,EAAE,IAJ0C;AAKjDC,MAAAA,MAAM,EAAE;AALyC,KAApC,CAAf;AAOAY,IAAAA,MAAM,CAACI,KAAP;AACD;AACF,C,CAED;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import {\n  Holistic,\n  POSE_CONNECTIONS,\n  HAND_CONNECTIONS,\n} from \"@mediapipe/holistic/holistic\";\nimport { Camera } from \"@mediapipe/camera_utils/camera_utils\";\nimport {\n  drawConnectors,\n  drawLandmarks,\n} from \"@mediapipe/drawing_utils/drawing_utils\";\nimport * as Facemesh from \"@mediapipe/face_mesh\";\nimport { FaceMesh } from \"@mediapipe/face_mesh\";\nexport const bodyPose = (webcamRef, canvasRef) => {\n  const holistic = new Holistic({\n    locateFile: (file) => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n    },\n  });\n  holistic.setOptions({\n    modelComplexity: 3,\n    smoothLandmarks: true,\n    enableSegmentation: true,\n    smoothSegmentation: true,\n    refineFaceLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5,\n  });\n  holistic.onResults((results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n    const videoHeight = webcamRef.current.video.videoHeight;\n\n    // Set canvas width\n    canvasRef.current.width = videoWidth;\n    canvasRef.current.height = videoHeight;\n\n    const canvasElement = canvasRef.current;\n    const canvasCtx = canvasElement.getContext(\"2d\");\n\n    canvasCtx.save();\n    canvasCtx.globalCompositeOperation = \"source-over\";\n    drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n      color: \"#00FF00\",\n      lineWidth: 4,\n    });\n    drawLandmarks(canvasCtx, results.poseLandmarks, {\n      color: \"#FF0000\",\n      lineWidth: 2,\n    });\n    drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n      color: \"#CC0000\",\n      lineWidth: 5,\n    });\n    drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n      color: \"#00FF00\",\n      lineWidth: 2,\n    });\n    drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n      color: \"#00CC00\",\n      lineWidth: 5,\n    });\n    drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n      color: \"#FF0000\",\n      lineWidth: 2,\n    });\n    canvasCtx.restore();\n  });\n\n  const camera = new Camera(webcamRef.current.video, {\n    onFrame: async () => {\n      await holistic.send({ image: webcamRef.current.video });\n    },\n    width: 1280,\n    height: 720,\n  });\n  camera.start();\n};\n\nexport default function solve(webcamRef ,  canvasRef) {\n  const faceMesh = new FaceMesh({\n    locateFile: (file) => {\n      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;\n    },\n  });\n\n  faceMesh.setOptions({\n    maxNumFaces: 4,\n    refineLandmarks: true,\n    minDetectionConfidence: 0.5,\n    minTrackingConfidence: 0.5,\n  });\n\n  faceMesh.onResults((results) => {\n    const videoWidth = webcamRef.current.video.videoWidth;\n  const videoHeight = webcamRef.current.video.videoHeight;\n\n  // Set canvas width\n  canvasRef.current.width = videoWidth;\n  canvasRef.current.height = videoHeight;\n\n  const canvasElement = canvasRef.current;\n  const canvasCtx = canvasElement.getContext(\"2d\");\n  canvasCtx.save();\n  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  canvasCtx.drawImage(\n    results.image,\n    0,\n    0,\n    canvasElement.width,\n    canvasElement.height\n  );\n  if (results.multiFaceLandmarks) {\n    for (const landmarks of results.multiFaceLandmarks) {\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_TESSELATION, {\n        color: \"#C0C0C070\",\n        lineWidth: 1,\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYE, {\n        color: \"#FF3030\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_RIGHT_EYEBROW, {\n        color: \"#FF3030\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYE, {\n        color: \"#30FF30\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LEFT_EYEBROW, {\n        color: \"#30FF30\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_FACE_OVAL, {\n        color: \"#E0E0E0\",\n      });\n      drawConnectors(canvasCtx, landmarks, Facemesh.FACEMESH_LIPS, {\n        color: \"#E0E0E0\",\n      });\n    }\n  }\n  canvasCtx.restore();\n  });\n\n  if (\n    typeof webcamRef.current !== \"undefined\" &&\n    webcamRef.current !== null\n  ) {\n    const camera = new Camera(webcamRef.current.video, {\n      onFrame: async () => {\n        await faceMesh.send({ image: webcamRef.current.video });\n      },\n      width: 1280,\n      height: 720,\n    });\n    camera.start();\n  }\n}\n\n// export default function BodyPoseDetection() {\n//   const webcamRef = useRef(null);\n//   const canvasRef = useRef(null);\n\n//   function Results(results) {\n//     // const video = webcamRef.current.video;\n//     const videoWidth = webcamRef.current.video.videoWidth;\n//     const videoHeight = webcamRef.current.video.videoHeight;\n\n//     // Set canvas width\n//     canvasRef.current.width = videoWidth;\n//     canvasRef.current.height = videoHeight;\n\n//     const canvasElement = canvasRef.current;\n//     const canvasCtx = canvasElement.getContext(\"2d\");\n\n//     canvasCtx.save();\n//     // canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n//     // canvasCtx.drawImage(\n//     //   results.segmentationMask,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n\n//     // Only overwrite existing pixels.\n//     // canvasCtx.globalCompositeOperation = \"source-in\";\n//     // canvasCtx.fillStyle = \"#00FF00\";\n//     // canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);\n\n//     // // Only overwrite missing pixels.\n//     // canvasCtx.globalCompositeOperation = \"destination-atop\";\n//     // canvasCtx.drawImage(\n//     //   results.image,\n//     //   0,\n//     //   0,\n//     //   canvasElement.width,\n//     //   canvasElement.height\n//     // );\n\n//     canvasCtx.globalCompositeOperation = \"source-over\";\n//     drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {\n//       color: \"#00FF00\",\n//       lineWidth: 4,\n//     });\n//     drawLandmarks(canvasCtx, results.poseLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     // drawConnectors(canvasCtx, results.faceLandmarks, FACEMESH_TESSELATION, {\n//     //   color: \"#C0C0C070\",\n//     //   lineWidth: 1,\n//     // });\n//     drawConnectors(canvasCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#CC0000\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.leftHandLandmarks, {\n//       color: \"#00FF00\",\n//       lineWidth: 2,\n//     });\n//     drawConnectors(canvasCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {\n//       color: \"#00CC00\",\n//       lineWidth: 5,\n//     });\n//     drawLandmarks(canvasCtx, results.rightHandLandmarks, {\n//       color: \"#FF0000\",\n//       lineWidth: 2,\n//     });\n//     canvasCtx.restore();\n//     console.log(\"done\");\n//   }\n//   // }\n\n//   // setInterval(())\n//   useEffect(() => {\n//     const holistic = new Holistic({\n//       locateFile: (file) => {\n//         return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`;\n//       },\n//     });\n//     holistic.setOptions({\n//       modelComplexity: 3,\n//       smoothLandmarks: true,\n//       enableSegmentation: true,\n//       smoothSegmentation: true,\n//       refineFaceLandmarks: true,\n//       minDetectionConfidence: 0.5,\n//       minTrackingConfidence: 0.5,\n//     });\n//     holistic.onResults(Results);\n\n//     const camera = new Camera(webcamRef.current.video, {\n//       onFrame: async () => {\n//         await holistic.send({ image: webcamRef.current.video });\n//       },\n//       width: 1280,\n//       height: 720,\n//     });\n//     camera.start();\n//   }, []);\n\n//   return (\n//     <center>\n//       <div className=\"App\">\n//         <Webcam\n//           ref={webcamRef}\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         />{\" \"}\n//         <canvas\n//           ref={canvasRef}\n//           className=\"output_canvas\"\n//           style={{\n//             position: \"absolute\",\n//             marginLeft: \"auto\",\n//             marginRight: \"auto\",\n//             left: 0,\n//             right: 0,\n//             textAlign: \"center\",\n//             zindex: 9,\n//             width: 640,\n//             height: 480,\n//           }}\n//         ></canvas>\n//       </div>\n//     </center>\n//   );\n// }\n"]},"metadata":{},"sourceType":"module"}